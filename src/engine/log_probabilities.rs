//! Operations involving log probabilities.

use serde::{Deserialize, Serialize};

/// A [`String`] which is guaranteed to not be empty.
#[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Serialize)]
pub struct NonEmptyString(String);

impl NonEmptyString {
    /// Creates a new [`NonEmptyString`] from a [`String`].
    pub fn new(s: String) -> Option<Self> {
        if s.is_empty() {
            None
        } else {
            Some(Self(s))
        }
    }

    /// Get a reference to the inner [`String`].
    pub fn inner(&self) -> &str {
        &self.0
    }

    /// Take the inner [`String`].
    pub fn into_inner(self) -> String {
        self.0
    }
}

#[derive(Serialize)]
pub(crate) struct LogProbabilitiesRequest {
    pub(crate) context: String,
    pub(crate) continuation: NonEmptyString,
}

/// This is logarithm of the probability that a continuation is generated after a context. It can be
/// used to answer questions when only a few answers (such as yes/no) are possible. It can also be
/// used to benchmark the models.
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq, Deserialize)]
pub struct LogProbabilities {
    logprob: f64,
    is_greedy: bool,
    total_tokens: usize,
}

impl LogProbabilities {
    /// Logarithm of the probability of generation of continuation preceded by context. It is
    /// always <= 0.
    pub const fn log_probability(&self) -> f64 {
        self.logprob
    }

    /// `true` if `continuation` would be generated by greedy sampling from `continuation`.
    pub const fn is_greedy(&self) -> bool {
        self.is_greedy
    }

    /// Indicate the total number of tokens. It is useful to estimate the number of compute
    /// resources used by the request.
    pub const fn total_tokens(&self) -> usize {
        self.total_tokens
    }
}
